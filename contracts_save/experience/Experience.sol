// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.24;

import {IExperience, JumpEntryRequest} from './IExperience.sol';
import {VectorAddress} from '../VectorAddress.sol';
import {IExperienceHook} from './IExperienceHook.sol';
import {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import {IExperienceRegistry} from './IExperienceRegistry.sol';
import {IPortalRegistry} from '../portal/IPortalRegistry.sol';
import {IPortalCondition} from '../portal/IPortalCondition.sol';
import {ExperienceV1Storage, LibExperienceV1Storage} from '../libraries/LibExperienceV1Storage.sol';    
import {BaseProxyStorage, LibBaseProxy, LibProxyAccess} from '../libraries/LibBaseProxy.sol';
import {ICompany} from '../company/ICompany.sol';
import {HookStorage, LibHooks} from '../libraries/LibHooks.sol';
import {BaseHookSupport} from '../BaseHookSupport.sol';

/**
 * @dev Arguments for initializing an experience.
 */
struct ExperienceInitData {
    uint256 entryFee;
    bytes connectionDetails;
}

/**
 * @dev Arguments for constructing the master copy of experience contract.
 */
struct ExperienceConstructorArgs {
    address experienceFactory;
    address portalRegistry;
    address experienceRegistry;
}

/**
 * @title Experience
 * @dev implementation of the IExperience interface.
 */
contract Experience is BaseHookSupport, ReentrancyGuard, IExperience {

    using LibProxyAccess for BaseProxyStorage;
    using LibHooks for HookStorage;

    //initialized when deploying master copy
    address public immutable experienceFactory;
    IPortalRegistry public immutable portalRegistry;
    IExperienceRegistry public immutable experienceRegistry;
    uint256 public constant override version = 1;

    modifier onlyFactory() {
        require(msg.sender == experienceFactory, "Experience: caller is not the factory");
        _;
    }

    modifier onlyPortalRegistry() {
        require(msg.sender == address(portalRegistry), "Experience: caller is not the portal registry");
        _;
    }

    modifier onlyRegistry {
        require(msg.sender == address(experienceRegistry), "Experience: caller is not the registry");
        _;
    }

    modifier onlyActive {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        require(s.active, "Experience: not active");
        _;
    }
    

    modifier onlyCompany() {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        require(msg.sender == address(s.company), "Experience: caller is not the company");
        _;
    }

    constructor(ExperienceConstructorArgs memory args) {
        require(args.experienceFactory != address(0), "Experience: zero address factory");
        require(args.portalRegistry != address(0), "Experience: zero address portalRegistry");
        require(args.experienceRegistry != address(0), "Experience: zero address experienceRegistry");
        experienceFactory = args.experienceFactory;
        portalRegistry = IPortalRegistry(args.portalRegistry);
        experienceRegistry = IExperienceRegistry(args.experienceRegistry);
    }

    //all fees go to the company
    receive() external payable {
        
    }

    /**
     * @inheritdoc IExperience
     */
    function init(address _company, string memory _name, VectorAddress memory vector, bytes memory initData) external onlyFactory override {
        //these args are passed through from the registry. The company initiated the 
        //registration so it's passed from the registry as the caller. The vector address
        //is generated by the company contract before passing to registry. The other args
        //are provided off chain as part of the registration process.
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        require(address(s.company) == address(0), "Experience: already initialized");
        
        s.company = ICompany(_company);
        ExperienceInitData memory data = abi.decode(initData, (ExperienceInitData));
        s.vectorAddress = vector;
        s.world = s.company.world();
        s.name = _name;
        s.entryFee = data.entryFee;
        s.connectionDetails = data.connectionDetails;
        s.active = true;
    }

    function isAdmin(address a) internal override view returns (bool) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return a == address(s.company);
    }

    /**
     * @inheritdoc IExperience
     */
    function isActive() external view returns (bool) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.active;
    }

    /**
        * @inheritdoc IExperience
     */
    function deactive() external override onlyRegistry {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        s.active = false;
        if(address(this).balance > 0) {
            payable(address(s.company)).transfer(address(this).balance);
        }
        emit ExperienceDeactivated();
    }

    /**
      * @dev convenience function to encode the init data for the experience.
     */
    function encodeInitData(ExperienceInitData memory data) external pure returns (bytes memory) {
        return abi.encode(data);
    }

    /**
     * @inheritdoc IExperience
     */
    function world() external view returns (address) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.world;
    }

    /**
     * @inheritdoc IExperience
     */
    function name() external view returns (string memory) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.name;
    }

    /**
     * @inheritdoc IExperience
     */
    function entryFee() external view returns (uint256) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.entryFee;
    }

    /**
     * @inheritdoc IExperience
     */
    function company() external view override returns (address) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return address(s.company);
    }

    /**
     * @inheritdoc IExperience
     */
    function vectorAddress() external view override returns (VectorAddress memory) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.vectorAddress;
    }

    /**
     * @inheritdoc IExperience
     */
    function connectionDetails() external view returns (bytes memory) {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        return s.connectionDetails;
    }

    

    /**
     * @inheritdoc IExperience
     */
    function addPortalCondition(IPortalCondition condition) public onlyCompany onlyActive {
        portalRegistry.addCondition(condition);
    }

    /**
     * @inheritdoc IExperience
     */
    function removePortalCondition() public onlyCompany onlyActive {
        portalRegistry.removeCondition();
    }

    /**
     * @inheritdoc IExperience
     */
    function changePortalFee(uint256 fee) public onlyCompany onlyActive {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        s.entryFee = fee;
        portalRegistry.changePortalFee(fee);
        emit PortalFeeChanged(fee);
    }

    /**
     * @inheritdoc IExperience
     */
    function entering(JumpEntryRequest memory request) external payable override nonReentrant onlyPortalRegistry onlyActive returns (bytes memory)  {
        ExperienceV1Storage storage s = LibExperienceV1Storage.load();
        address hook = LibHooks.load().getHook();
        if(hook != address(0)) {
            bool ok = IExperienceHook(hook).beforeJumpEntry(address(this), request.sourceWorld, request.sourceCompany, request.avatar);
            require(ok, "Experience: hook disallowed entry");
        }
        
        if(s.entryFee > 0) {
            require(msg.value == s.entryFee, "Experience: incorrect entry fee");
            payable(address(s.company)).transfer(msg.value);
        }
        return s.connectionDetails;
    }

    /**
     * @inheritdoc IExperience
     */
    function upgrade(bytes memory initData) external override onlyCompany onlyActive returns (address) {
        address hook = LibHooks.load().getHook();
        if(hook != address(0)) {
            require(IExperienceHook(hook).beforeUpgrade(initData),"Experience: hook disallowed upgrade");
        }
        return experienceRegistry.upgradeExperience(initData);
    }

    /**
     * @inheritdoc IExperience
     */
    function upgradeComplete(address nextVersion) public override onlyFactory onlyActive {
        BaseProxyStorage storage ps = LibBaseProxy.load();
        address old = ps.implementation;
        ps.implementation = nextVersion;
        emit ExperienceUpgraded(old, nextVersion);
    }
}